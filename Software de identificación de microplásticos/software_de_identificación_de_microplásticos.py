# -*- coding: utf-8 -*-
"""Software de identificación de microplásticos.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IrmrrKIHZ6YLzGsLDr5kjfVCsw4u5FIg

#Software de Identificación de microplásticos
"""

#instalaciones requeridas
!pip install reverse_geocode
!python -m pip install 'git+https://github.com/facebookresearch/detectron2.git'
!pip install roboflow

# Commented out IPython magic to ensure Python compatibility.
#Librerías

#De uso general
import os #Para funcionalidades dependientes del sistema operativo
import cv2 #Para el procesamiento de imágenes
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt #Para crear gráficos
import numpy as np #Para operar funciones, vectores y matrices
import pandas as pd #Para manipulación y análisis de datos
from PIL import Image #Para abrir, manipular y guardar imágenes en varios formatos

#Conjunto de librerías para geolocalización
import reverse_geocode #Para convertir coordenadas geográficas (latitud y longitud) en direcciones o nombres de lugares
import folium #Para la creación de mapas interactivos
from IPython.display import display

# %matplotlib inline
#Conjunto de librerías para la detección de objetos
import torch #ML basada en el cálculo automático de gradientes y en redes neuronales profundas.
import detectron2 #Detección de objetos.
from detectron2.data.datasets import register_coco_instances
from detectron2.data import DatasetCatalog, MetadataCatalog
from detectron2.utils.visualizer import Visualizer
from detectron2.utils.visualizer import ColorMode
from detectron2 import model_zoo
from detectron2.config import get_cfg
from detectron2.engine import DefaultPredictor
from detectron2.evaluation import COCOEvaluator, inference_on_dataset
from detectron2.data import build_detection_test_loader
from detectron2.engine import DefaultTrainer
import logging #Para registrar eventos y mensajes durante la ejecución del programa
from detectron2.utils.logger import setup_logger
from roboflow import Roboflow #Ofrece datasets y herramientas para el entrenamiento de modelos

##Bienvenida
print("Bienvenido al Software de conteo y reconocimiento de microplásticos")
print("Recuerda:")
print("1-.Tener a la mano tu ubicación")
print("2-.La fotos deben ser de microplásticos filtrados es decir sin ningún otro material en lo posible")
print("3-.Las fotos deben ser claras para obtener mejores resultados")

"""##Modelo de Conteo de microplásticos"""

#Descarga y configuración del dataset
rf = Roboflow(api_key="Dlwgwe3psTHRPIuQlsbV")
project = rf.workspace("panats-mp-project").project("microplastic-dataset")
dataset = project.version(19).download("coco")

#Definición de rutas y nombres
DATA_SET_NAME = dataset.name.replace(" ", "-")
ANNOTATIONS_FILE_NAME = "_annotations.coco.json"

#Registro del dataset
TRAIN_DATA_SET_NAME = f"{DATA_SET_NAME}-train"
TRAIN_DATA_SET_IMAGES_DIR_PATH = os.path.join(dataset.location, "train")
TRAIN_DATA_SET_ANN_FILE_PATH = os.path.join(dataset.location, "train", ANNOTATIONS_FILE_NAME)

register_coco_instances(
    name=TRAIN_DATA_SET_NAME,
    metadata={},
    json_file=TRAIN_DATA_SET_ANN_FILE_PATH,
    image_root=TRAIN_DATA_SET_IMAGES_DIR_PATH
)

#Validación del dataset
VALID_DATA_SET_NAME = f"{DATA_SET_NAME}-valid"
VALID_DATA_SET_IMAGES_DIR_PATH = os.path.join(dataset.location, "valid")
VALID_DATA_SET_ANN_FILE_PATH = os.path.join(dataset.location, "valid", ANNOTATIONS_FILE_NAME)

register_coco_instances(
    name=VALID_DATA_SET_NAME,
    metadata={},
    json_file=VALID_DATA_SET_ANN_FILE_PATH,
    image_root=VALID_DATA_SET_IMAGES_DIR_PATH
)

# Configuración del modelo
cfg = get_cfg()
cfg.merge_from_file(model_zoo.get_config_file("COCO-Detection/faster_rcnn_R_50_FPN_3x.yaml"))
cfg.DATASETS.TRAIN = (TRAIN_DATA_SET_NAME,)
cfg.DATASETS.TEST = (VALID_DATA_SET_NAME,)
cfg.DATALOADER.NUM_WORKERS = 2
cfg.MODEL.WEIGHTS = model_zoo.get_checkpoint_url("COCO-Detection/faster_rcnn_R_50_FPN_3x.yaml")
cfg.SOLVER.IMS_PER_BATCH = 2
cfg.SOLVER.BASE_LR = 0.001
cfg.SOLVER.MAX_ITER = 3000
cfg.MODEL.ROI_HEADS.BATCH_SIZE_PER_IMAGE = 128
cfg.MODEL.ROI_HEADS.NUM_CLASSES = 7  # Número de categorías de microplásticos


# Creación del entrenador
trainer = DefaultTrainer(cfg)
trainer.resume_or_load(resume=False)
trainer.train()

# Configuración del modelo
cfg.MODEL.WEIGHTS = "./output/model_final.pth"  # Ruta a los pesos del modelo entrenado
cfg.MODEL.ROI_HEADS.SCORE_THRESH_TEST = 0.7  # Umbral para la predicción
cfg.DATASETS.TEST = ("microplastic-dataset-valid", )

predictor = DefaultPredictor(cfg) #Predictor

"""##Ingreso de un fotografía de microplásticos para analizar y de ubicación"""

# Ruta para guardar el archivo CSV
archivo_csv = 'microplastico_y_ubicaciones.csv'

# Solicitar al usuario que ingrese el nombre del archivo de imagen
image_filename = input("Ingrese el nombre del archivo de la imagen (con extensión): ")

# Leer la imagen
image_path = os.path.join(VALID_DATA_SET_IMAGES_DIR_PATH, image_filename)
image = cv2.imread(image_path)

if image is None:
    raise FileNotFoundError(f"La imagen '{image_filename}' no se encuentra en la ruta '{VALID_DATA_SET_IMAGES_DIR_PATH}'.")

# Detectar microplásticos
outputs = predictor(image)
instances = outputs["instances"].to("cpu")
pred_boxes = instances.pred_boxes.tensor.numpy()  # Coordenadas de las cajas delimitadoras

# Convertir la imagen a HSV
hsv_image = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)

# Definir los rangos de color en HSV
color_ranges = {
    "Verde": ((0, 0, 200), (180, 30, 255)),
    "Azul": ((100, 150, 0), (140, 255, 255)),
    "Amarillo": ((20, 100, 100), (30, 255, 255)),
    "Blanco": ((40, 40, 40), (80, 255, 255)),
    "Rojo": ((0, 100, 100), (10, 255, 255)),
}

# Contar los microplásticos por color
color_counts = {color: 0 for color in color_ranges}

# Función para encontrar el color más cercano
def get_closest_color(hsv_image, x, y, w, h):
    roi = hsv_image[y:y+h, x:x+w]
    mean_color = cv2.mean(roi)[:3]
    min_dist = float('inf')
    closest_color = None
    for color, (lower, upper) in color_ranges.items():
        lower_bound = np.array(lower, dtype="uint8")
        upper_bound = np.array(upper, dtype="uint8")
        mask = cv2.inRange(hsv_image, lower_bound, upper_bound)
        mask_mean_color = cv2.mean(hsv_image, mask=mask)[:3]
        dist = np.linalg.norm(np.array(mean_color) - np.array(mask_mean_color))
        if dist < min_dist:
            min_dist = dist
            closest_color = color
    return closest_color

# Contar y asignar colores a cada microplástico detectado
microplastico_data = []
for box in pred_boxes:
    x1, y1, x2, y2 = box
    x, y, w, h = int(x1), int(y1), int(x2 - x1), int(y2 - y1)
    color = get_closest_color(hsv_image, x, y, w, h)
    if color:
        color_counts[color] += 1
        # Dibujar la caja delimitadora y el color en la imagen
        cv2.rectangle(image, (x, y), (x+w, y+h), (0, 255, 0), 2)
        cv2.putText(image, color, (x, y-10), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)
        # Agregar los datos al microplastico_data
        microplastico_data.append([color, x, y, w, h])

# Función para solicitar la entrada de datos
def solicitar_datos():
    latitud = input("Ingrese la latitud: ")
    longitud = input("Ingrese la longitud: ")
    descripcion = input("Ingrese la descripción de la ubicación (opcional): ")
    pais = obtener_pais(latitud, longitud)
    if not descripcion:
        descripcion = f'Ubicación: {latitud}, {longitud}, País: {pais}'
    mapa = folium.Map(location=[float(latitud), float(longitud)], zoom_start=15)
    folium.Marker(
        location=[float(latitud), float(longitud)],
        popup=descripcion,
        icon=folium.Icon(color='blue', icon='info-sign')
    ).add_to(mapa)
    display(mapa)
    return [latitud, longitud, pais, descripcion]

# Función para obtener información de la ubicación basada en coordenadas
def obtener_pais(lat, lon):
    results = reverse_geocode.search([(float(lat), float(lon))])
    if results:
        return results[0]['country']
    return 'Desconocido'

# Solicitar los datos
ubicacion_data = []
entrada = solicitar_datos()
if entrada:
    ubicacion_data.append(entrada)

# Contar los microplásticos por color y exportar a CSV
data = {
    "Color": [],
    "Conteo": []
}

total_microplasticos = 0
for color, count in color_counts.items():
    if count > 0:
        data["Color"].append(color)
        data["Conteo"].append(count)
        total_microplasticos += count

# Agregar el total de microplásticos
data["Color"].append("Total")
data["Conteo"].append(total_microplasticos)

# Convertir a DataFrame y exportar a CSV
df_microplastico = pd.DataFrame(data)

# Agregar los datos de microplásticos y ubicaciones en el mismo CSV
df_ubicaciones = pd.DataFrame(ubicacion_data, columns=["Latitud", "Longitud", "País", "Descripción"])
df_final = pd.concat([df_microplastico, df_ubicaciones], axis=1)

df_final.to_csv(archivo_csv, index=False)

print(f"Los resultados se han guardado en '{archivo_csv}'.")

# Imprimir el resumen del conteo
print("\nResumen del conteo de microplásticos:")
for color, count in color_counts.items():
    print(f"{color}: {count}")

print(f"\nTotal de microplásticos detectados: {total_microplasticos}")

# Guardar la imagen con los rectángulos dibujados
output_image_path = os.path.join(VALID_DATA_SET_IMAGES_DIR_PATH, 'image_with_boxes.jpg')
cv2.imwrite(output_image_path, image)
print(f"Imagen con los rectángulos guardada en '{output_image_path}'.")

# Mostrar la imagen con las cajas delimitadoras y colores
cv2_imshow(image)  # Utiliza cv2.imshow en otros entornos
print(df_final)

print("Gracias :)")